<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR ‡πÇ‡∏•‡∏Å‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (Pro)</title>
    
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;600&display=swap" rel="stylesheet">

    <script>
        AFRAME.registerComponent("gesture-detector", {
            schema: { element: { default: "" } },
            init: function() {
                this.targetElement = this.data.element && document.querySelector(this.data.element);
                if (!this.targetElement) this.targetElement = this.el;
                this.internalState = { previousState: null };
                this.emitGestureEvent = this.emitGestureEvent.bind(this);
                this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
                this.targetElement.addEventListener("touchend", this.emitGestureEvent);
                this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
            },
            emitGestureEvent(event) {
                const currentState = this.getTouchState(event);
                const previousState = this.internalState.previousState;
                const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
                if (gestureContinues) {
                    const eventDetail = {
                        positionChange: { x: currentState.position.x - previousState.position.x, y: currentState.position.y - previousState.position.y },
                        spreadChange: currentState.spread - previousState.spread
                    };
                    if (currentState.touchCount == 2) this.el.emit("twofingermove", eventDetail);
                    else this.el.emit("onefingermove", eventDetail);
                }
                this.internalState.previousState = currentState;
            },
            getTouchState(event) {
                if (event.touches.length === 0) return null;
                const touchList = [];
                for (let i = 0; i < event.touches.length; i++) touchList.push(event.touches[i]);
                const touchCenter = touchList.reduce((acc, t) => ({ x: acc.x + t.clientX, y: acc.y + t.clientY }), { x: 0, y: 0 });
                touchCenter.x /= touchList.length; touchCenter.y /= touchList.length;
                const spread = touchList.length < 2 ? 0 : Math.sqrt(Math.pow(touchList[0].clientX - touchList[1].clientX, 2) + Math.pow(touchList[0].clientY - touchList[1].clientY, 2));
                return { touchCount: touchList.length, position: touchCenter, spread: spread };
            }
        });

        AFRAME.registerComponent("gesture-handler", {
            schema: { enabled: { default: true }, rotationFactor: { default: 5 }, minScale: { default: 0.1 }, maxScale: { default: 8 } },
            init: function() {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;
                this.el.sceneEl.addEventListener("markerFound", (e) => this.isVisible = true);
                this.el.sceneEl.addEventListener("markerLost", (e) => this.isVisible = false);
                this.el.sceneEl.addEventListener("twofingermove", this.handleScale);
                this.el.sceneEl.addEventListener("onefingermove", this.handleRotation);
            },
            handleRotation: function(event) {
                if (this.isVisible) {
                    this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * 0.005;
                    this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * 0.005;
                }
            },
            handleScale: function(event) {
                if (this.isVisible) {
                    this.scaleFactor *= 1 + event.detail.spreadChange / window.innerWidth;
                    this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
                    this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
                    this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
                    this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
                }
            }
        });
    </script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Kanit', sans-serif; }

        /* 3. Loading Screen (‡∏à‡∏∞‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏£‡πâ‡∏≠‡∏°) */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0b0f19; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out; /* Fade out effect */
        }
        .loader {
            border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid #00d2ff;
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .loading-text { color: white; font-size: 1.2em; letter-spacing: 1px; }

        /* 4. UI Overlay (‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á) */
        #ui-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* ‡πÉ‡∏´‡πâ‡∏Å‡∏î‡∏ó‡∏∞‡∏•‡∏∏‡πÑ‡∏õ‡∏´‡∏°‡∏∏‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÑ‡∏î‡πâ */
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 100;
        }

        /* Header Bar */
        .header-bar {
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);
            padding: 20px; text-align: center; color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .header-bar h1 { margin: 0; font-size: 1.4em; }
        .header-bar p { margin: 5px 0 0; font-size: 0.9em; opacity: 0.8; }

        /* Scanning Frame (‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏•‡πá‡∏á) */
        .scan-frame {
            width: 250px; height: 250px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.3); /* ‡∏â‡∏≤‡∏Å‡∏°‡∏∑‡∏î‡∏£‡∏≠‡∏ö‡πÜ */
        }
        .scan-frame::after {
            content: ''; position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px;
            border: 2px dashed rgba(0, 210, 255, 0.8); border-radius: 25px;
            animation: pulse-border 2s infinite;
        }

        /* Footer Controls */
        .footer-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px); /* ‡∏Å‡∏£‡∏∞‡∏à‡∏Å‡∏°‡∏±‡∏ß */
            padding: 15px; margin: 20px;
            border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);
            text-align: center; color: white;
        }
        .icon-row { display: flex; justify-content: center; gap: 20px; font-size: 0.9em; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse-border { 0% { transform: scale(0.95); opacity: 0.5; } 50% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(0.95); opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <div class="loading-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á...</div>
    </div>

    <div id="ui-overlay">
        <div class="header-bar">
            <h1>‡πÇ‡∏•‡∏Å‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</h1>
            <p>‡∏™‡πà‡∏≠‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÇ‡∏°‡πÄ‡∏î‡∏• 3 ‡∏°‡∏¥‡∏ï‡∏¥</p>
        </div>
        
        <div class="scan-frame"></div>

        <div class="footer-bar">
            <div class="icon-row">
                <span>üëÜ 1 ‡∏ô‡∏¥‡πâ‡∏ß ‡∏´‡∏°‡∏∏‡∏ô</span>
                <span>‚úåÔ∏è 2 ‡∏ô‡∏¥‡πâ‡∏ß ‡∏ã‡∏π‡∏°</span>
            </div>
        </div>
    </div>

    <a-scene 
        mindar-image="imageTargetSrc: ./targets.mind; maxTrack: 2; uiScanning: no; filterMinCF:0.0001; filterBeta: 0.001;" 
        color-space="sRGB" 
        renderer="colorManagement: true, physicallyCorrectLights, antialias: true" 
        vr-mode-ui="enabled: false" 
        device-orientation-permission-ui="enabled: false"
        gesture-detector>

        <a-assets>
            <a-asset-item id="model-earth" src="./eart.1blend.glb"></a-asset-item>
            <a-asset-item id="model-core" src="./_core2.glb"></a-asset-item>
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <a-entity mindar-image-target="targetIndex: 0">
            <a-entity 
                gltf-model="#model-core" 
                rotation="90 0 0" position="0 0 0" scale="0.5 0.5 0.5" 
                gesture-handler>
            </a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 1">
            <a-entity 
                gltf-model="#model-earth" 
                rotation="90 0 0" position="0 0 0" scale="0.5 0.5 0.5" 
                gesture-handler>
            </a-entity>
        </a-entity>

    </a-scene>

    <script>
        // ‡∏£‡∏∞‡∏ö‡∏ö Fade Out ‡∏´‡∏ô‡πâ‡∏≤ Loading ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°
        const scene = document.querySelector('a-scene');
        const loadingOverlay = document.getElementById('loading-overlay');

        scene.addEventListener('arReady', (event) => {
            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠ AR ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πâ‡∏≤ Loading ‡∏à‡∏≤‡∏á‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
            loadingOverlay.style.opacity = '0';
            // ‡∏£‡∏≠ animation ‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ã‡πà‡∏≠‡∏ô‡∏ñ‡∏≤‡∏ß‡∏£
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 800);
        });

        // (Optional) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏à‡∏≠ Marker ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏•‡πá‡∏á‡∏Å‡πá‡πÑ‡∏î‡πâ
        // scene.addEventListener('targetFound', (e) => { ... });
    </script>

</body>
</html>